// 
// (C) 2006-2007 The SharpOS Project Team (http://www.sharpos.org)
//
// Authors:
//	Sander van Rossen <sander.vanrossen@gmail.com>
//	William Lahti <xfurious@gmail.com>
//
// Licensed under the terms of the GNU GPL v3,
//  with Classpath Linking Exception for Libraries
//

//#define VERBOSE_BinaryTool

using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using SharpOS.Kernel;
using SharpOS.Kernel.ADC;
using SharpOS.AOT.X86;
using SharpOS.AOT.IR;
using SharpOS.Kernel.Foundation;
using AOTAttr = SharpOS.AOT.Attributes;

//#define VERBOSE_BinaryTool

namespace SharpOS.Kernel.Foundation {
	public unsafe class BinaryTool {
		public static int Read7BitInt (void* ptr, int* ret_len)
		{
			// Originally from Mono: mcs/class/corlib/System.IO/BinaryReader.cs
			// Copyright (C) 2004 Novell

			int ret = 0;
			int shift = 0;
			byte* bp = (byte*) ptr;
			byte b;

			do {
				b = *bp;
				++bp;

				if (ret_len != null)
					(*ret_len)++;

				ret = ret | (((int) (b & 0x7f)) << shift);
				shift += 7;
			} while ((b & 0x80) == 0x80);

#if VERBOSE_BinaryTool
			TextMode.WriteLine ("read7bit: ", ret);
#endif

			return ret;
		}

		/// <summary>
		/// Reads a length-prefixed string as generated by a .NET BinaryReader class.
		/// This involves first reading a variable-size 7-bit integer, then the string,
		/// placing it in the provided buffer. If the buffer is not large enough, the
		/// 'error' parameter is set to 1. The string is still readable in 'buffer',
		/// but it is shortened. To prevent this, you can call Read7BitEncodedInt first
		/// and size the buffer appropriately. Returns the amount of bytes that the
		/// length-prefixed string took up (including the bytes that contained the length),
		/// so it can be skipped when reading more data. The 'buffer' will be null-terminated,
		/// even if it is too small. The returned value is not reduced if the buffer is too
		/// small (IE, it represents the entire string, not the shortened version).
		/// </summary>
		public static int ReadPrefixedString (void* ptr, byte* buffer, int bufferLen, int* error)
		{
			int ilen = 0;
			int size = 0;
			int x = 0;
			byte* bp = (byte*) ptr;

			*error = 0;
			size = Read7BitInt (ptr, &ilen);
			bp += ilen;

#if VERBOSE_BinaryTool
			TextMode.Write ("bufferLen: ");
			TextMode.Write (bufferLen, false);
			TextMode.WriteLine ();

			TextMode.Write ("size: ");
			TextMode.Write (size, false);
			TextMode.WriteLine ();
			
			TextMode.Write ("ilen: ");
			TextMode.Write (ilen, false);
			TextMode.WriteLine ();

			TextMode.WriteLine ("&buffer: 0x", (int)buffer);
			TextMode.WriteLine ("&ilen: 0x", (int)&ilen);
#endif
			buffer [bufferLen - 1] = 0;

			for (x = 0; x < size && x < bufferLen - 1; ++x) {
#if VERBOSE_BinaryTool
				TextMode.Write ("copying ");
				TextMode.WriteChar (bp [x]);
				TextMode.WriteLine ();
#endif
				buffer [x] = bp [x];
			}

			buffer [x] = 0;

			/*
			if (x != size-1)
				*error = 1;	// the buffer was too small
			*/

#if VERBOSE_BinaryTool
			TextMode.Write ("size: ");
			TextMode.Write (size, false);
			TextMode.WriteLine ();
			TextMode.Write ("ilen: ");
			TextMode.Write (ilen, false);
			TextMode.WriteLine ();
			TextMode.Write ("retx: ");
			TextMode.WriteLine (buffer);
#endif
			return ilen + size;
		}

		public static int ReadPrefixedString (void* ptr, byte* buffer, int bufferLen)
		{
			int error = 0;

			return ReadPrefixedString (ptr, buffer, bufferLen, &error);
		}
	}
}

